# ğŸ“ Ù…ÙˆØ§ØµÙØ§Øª Ø§Ù„Ø³Ø¨ÙˆØ±Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠØ©
## ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø´Ø±Ø­ Ø¥Ù„Ù‰ ØªØ¬Ø±Ø¨Ø© Ø¨ØµØ±ÙŠØ© ØªÙØ§Ø¹Ù„ÙŠØ©

---

## ğŸ¯ **Ø§Ù„Ø±Ø¤ÙŠØ© Ø§Ù„Ø¹Ø§Ù…Ø©**

### **Ø§Ù„Ù‡Ø¯Ù:**
Ø¥Ù†Ø´Ø§Ø¡ Ø³Ø¨ÙˆØ±Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø°ÙƒÙŠØ© ÙŠØªØ­ÙƒÙ… Ø¨Ù‡Ø§ Ø§Ù„Ù…Ø¹Ù„Ù… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù„ØªÙˆØ¶ÙŠØ­ Ø§Ù„Ù…ÙØ§Ù‡ÙŠÙ… Ø¨ØµØ±ÙŠØ§Ù‹ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø´Ø±Ø­ Ø§Ù„ØµÙˆØªÙŠ.

### **Ø§Ù„ØªØ¬Ø±Ø¨Ø© Ø§Ù„Ù…Ø³ØªÙ‡Ø¯ÙØ©:**
```
Ø§Ù„Ù…Ø¹Ù„Ù…: (ØµÙˆØªÙŠØ§Ù‹) "Ø¯Ø¹Ù†Ø§ Ù†Ø±Ø³Ù… Ù…Ø«Ù„Ø«Ø§Ù‹ Ù‚Ø§Ø¦Ù… Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ù„ÙÙ‡Ù… Ù†Ø¸Ø±ÙŠØ© ÙÙŠØ«Ø§ØºÙˆØ±Ø³"
Ø§Ù„Ø³Ø¨ÙˆØ±Ø©: (ØªØ±Ø³Ù… ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹) Ù…Ø«Ù„Ø« Ù‚Ø§Ø¦Ù… Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ù…Ø¹ ØªØ³Ù…ÙŠØ© Ø§Ù„Ø£Ø¶Ù„Ø§Ø¹
Ø§Ù„Ù…Ø¹Ù„Ù…: (ØµÙˆØªÙŠØ§Ù‹) "Ù‡Ø°Ø§ Ù‡Ùˆ Ø§Ù„Ø¶Ù„Ø¹ Ø§Ù„Ø£ÙˆÙ„ØŒ Ø·ÙˆÙ„Ù‡ 3 ÙˆØ­Ø¯Ø§Øª"
Ø§Ù„Ø³Ø¨ÙˆØ±Ø©: (ØªÙƒØªØ¨) "Ø£ = 3" Ø¨Ø¬Ø§Ù†Ø¨ Ø§Ù„Ø¶Ù„Ø¹
Ø§Ù„Ù…Ø¹Ù„Ù…: (ØµÙˆØªÙŠØ§Ù‹) "ÙˆØ§Ù„Ø¶Ù„Ø¹ Ø§Ù„Ø«Ø§Ù†ÙŠ Ø·ÙˆÙ„Ù‡ 4 ÙˆØ­Ø¯Ø§Øª"
Ø§Ù„Ø³Ø¨ÙˆØ±Ø©: (ØªÙƒØªØ¨) "Ø¨ = 4" Ø¨Ø¬Ø§Ù†Ø¨ Ø§Ù„Ø¶Ù„Ø¹ Ø§Ù„Ø«Ø§Ù†ÙŠ
Ø§Ù„Ù…Ø¹Ù„Ù…: (ØµÙˆØªÙŠØ§Ù‹) "Ø§Ù„Ø¢Ù†ØŒ Ù…Ø§ Ø·ÙˆÙ„ Ø§Ù„ÙˆØªØ±ØŸ"
Ø§Ù„Ø³Ø¨ÙˆØ±Ø©: (ØªØ¸Ù„Ù„ Ø§Ù„ÙˆØªØ± ÙˆØªÙƒØªØ¨) "Ø¬ = ØŸ"
```

---

## ğŸ”§ **Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„ØªÙ‚Ù†ÙŠØ©**

### **1. Ù…Ø­Ø±Ùƒ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ**

```typescript
// lib/whiteboard-engine.ts
export interface Point {
  x: number;
  y: number;
}

export interface DrawingElement {
  id: string;
  type: 'line' | 'circle' | 'rectangle' | 'text' | 'arrow' | 'curve';
  points: Point[];
  style: DrawingStyle;
  timestamp: number;
  animationDuration?: number;
}

export interface DrawingStyle {
  strokeColor: string;
  fillColor?: string;
  strokeWidth: number;
  fontSize?: number;
  fontFamily?: string;
  opacity: number;
}

export class WhiteboardEngine {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  private elements: DrawingElement[] = [];
  private animationQueue: DrawingElement[] = [];
  
  constructor(canvas: HTMLCanvasElement) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d')!;
    this.setupCanvas();
  }
  
  private setupCanvas() {
    // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙƒØ§Ù†ÙØ§Ø³ Ù„Ù„Ø±Ø³Ù… Ø¹Ø§Ù„ÙŠ Ø§Ù„Ø¬ÙˆØ¯Ø©
    const dpr = window.devicePixelRatio || 1;
    const rect = this.canvas.getBoundingClientRect();
    
    this.canvas.width = rect.width * dpr;
    this.canvas.height = rect.height * dpr;
    
    this.ctx.scale(dpr, dpr);
    this.canvas.style.width = rect.width + 'px';
    this.canvas.style.height = rect.height + 'px';
  }
  
  // Ø±Ø³Ù… Ø®Ø·
  drawLine(from: Point, to: Point, style: DrawingStyle, animated = true): string {
    const element: DrawingElement = {
      id: this.generateId(),
      type: 'line',
      points: [from, to],
      style,
      timestamp: Date.now(),
      animationDuration: animated ? 1000 : 0
    };
    
    if (animated) {
      this.animateElement(element);
    } else {
      this.renderElement(element);
    }
    
    this.elements.push(element);
    return element.id;
  }
  
  // Ø±Ø³Ù… Ø¯Ø§Ø¦Ø±Ø©
  drawCircle(center: Point, radius: number, style: DrawingStyle, animated = true): string {
    const element: DrawingElement = {
      id: this.generateId(),
      type: 'circle',
      points: [center, { x: center.x + radius, y: center.y }],
      style,
      timestamp: Date.now(),
      animationDuration: animated ? 1500 : 0
    };
    
    if (animated) {
      this.animateElement(element);
    } else {
      this.renderElement(element);
    }
    
    this.elements.push(element);
    return element.id;
  }
  
  // ÙƒØªØ§Ø¨Ø© Ù†Øµ
  writeText(position: Point, text: string, style: DrawingStyle, animated = true): string {
    const element: DrawingElement = {
      id: this.generateId(),
      type: 'text',
      points: [position],
      style: { ...style, text },
      timestamp: Date.now(),
      animationDuration: animated ? text.length * 100 : 0
    };
    
    if (animated) {
      this.animateTextElement(element);
    } else {
      this.renderElement(element);
    }
    
    this.elements.push(element);
    return element.id;
  }
  
  // Ø±Ø³Ù… Ù…Ø«Ù„Ø«
  drawTriangle(p1: Point, p2: Point, p3: Point, style: DrawingStyle, animated = true): string {
    const element: DrawingElement = {
      id: this.generateId(),
      type: 'triangle',
      points: [p1, p2, p3],
      style,
      timestamp: Date.now(),
      animationDuration: animated ? 2000 : 0
    };
    
    if (animated) {
      this.animateTriangle(element);
    } else {
      this.renderElement(element);
    }
    
    this.elements.push(element);
    return element.id;
  }
  
  // Ø±Ø³Ù… Ø³Ù‡Ù…
  drawArrow(from: Point, to: Point, style: DrawingStyle, animated = true): string {
    const element: DrawingElement = {
      id: this.generateId(),
      type: 'arrow',
      points: [from, to],
      style,
      timestamp: Date.now(),
      animationDuration: animated ? 800 : 0
    };
    
    if (animated) {
      this.animateElement(element);
    } else {
      this.renderElement(element);
    }
    
    this.elements.push(element);
    return element.id;
  }
  
  private animateElement(element: DrawingElement) {
    const startTime = Date.now();
    const duration = element.animationDuration || 1000;
    
    const animate = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      this.clearCanvas();
      this.renderAllElements();
      this.renderElementWithProgress(element, progress);
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      }
    };
    
    requestAnimationFrame(animate);
  }
  
  private animateTextElement(element: DrawingElement) {
    const text = element.style.text || '';
    const startTime = Date.now();
    const duration = element.animationDuration || 1000;
    
    const animate = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const charactersToShow = Math.floor(progress * text.length);
      
      this.clearCanvas();
      this.renderAllElements();
      
      // Ø±Ø³Ù… Ø§Ù„Ù†Øµ ØªØ¯Ø±ÙŠØ¬ÙŠØ§Ù‹
      const partialText = text.substring(0, charactersToShow);
      this.renderText(element.points[0], partialText, element.style);
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      }
    };
    
    requestAnimationFrame(animate);
  }
  
  private renderElement(element: DrawingElement) {
    this.ctx.save();
    this.applyStyle(element.style);
    
    switch (element.type) {
      case 'line':
        this.renderLine(element.points[0], element.points[1]);
        break;
      case 'circle':
        this.renderCircle(element.points[0], this.getDistance(element.points[0], element.points[1]));
        break;
      case 'text':
        this.renderText(element.points[0], element.style.text || '', element.style);
        break;
      case 'triangle':
        this.renderTriangle(element.points[0], element.points[1], element.points[2]);
        break;
      case 'arrow':
        this.renderArrow(element.points[0], element.points[1]);
        break;
    }
    
    this.ctx.restore();
  }
  
  private applyStyle(style: DrawingStyle) {
    this.ctx.strokeStyle = style.strokeColor;
    this.ctx.fillStyle = style.fillColor || style.strokeColor;
    this.ctx.lineWidth = style.strokeWidth;
    this.ctx.globalAlpha = style.opacity;
    
    if (style.fontSize) {
      this.ctx.font = `${style.fontSize}px ${style.fontFamily || 'Arial'}`;
    }
  }
  
  private renderLine(from: Point, to: Point) {
    this.ctx.beginPath();
    this.ctx.moveTo(from.x, from.y);
    this.ctx.lineTo(to.x, to.y);
    this.ctx.stroke();
  }
  
  private renderCircle(center: Point, radius: number) {
    this.ctx.beginPath();
    this.ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI);
    this.ctx.stroke();
  }
  
  private renderText(position: Point, text: string, style: DrawingStyle) {
    this.ctx.fillText(text, position.x, position.y);
  }
  
  private renderTriangle(p1: Point, p2: Point, p3: Point) {
    this.ctx.beginPath();
    this.ctx.moveTo(p1.x, p1.y);
    this.ctx.lineTo(p2.x, p2.y);
    this.ctx.lineTo(p3.x, p3.y);
    this.ctx.closePath();
    this.ctx.stroke();
  }
  
  private renderArrow(from: Point, to: Point) {
    // Ø±Ø³Ù… Ø§Ù„Ø®Ø· Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
    this.renderLine(from, to);
    
    // Ø±Ø³Ù… Ø±Ø£Ø³ Ø§Ù„Ø³Ù‡Ù…
    const angle = Math.atan2(to.y - from.y, to.x - from.x);
    const arrowLength = 15;
    const arrowAngle = Math.PI / 6;
    
    const arrowPoint1 = {
      x: to.x - arrowLength * Math.cos(angle - arrowAngle),
      y: to.y - arrowLength * Math.sin(angle - arrowAngle)
    };
    
    const arrowPoint2 = {
      x: to.x - arrowLength * Math.cos(angle + arrowAngle),
      y: to.y - arrowLength * Math.sin(angle + arrowAngle)
    };
    
    this.renderLine(to, arrowPoint1);
    this.renderLine(to, arrowPoint2);
  }
  
  // Ù…Ø³Ø­ Ø§Ù„Ø³Ø¨ÙˆØ±Ø©
  clear() {
    this.elements = [];
    this.clearCanvas();
  }
  
  private clearCanvas() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
  
  private renderAllElements() {
    this.elements.forEach(element => this.renderElement(element));
  }
  
  private generateId(): string {
    return `element_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  private getDistance(p1: Point, p2: Point): number {
    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
  }
}
```

### **2. ÙˆØ§Ø¬Ù‡Ø© Function Calling Ù„Ù„Ù…Ø¹Ù„Ù… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ**

```typescript
// lib/whiteboard-functions.ts
export interface WhiteboardFunction {
  name: string;
  description: string;
  parameters: {
    type: 'object';
    properties: Record<string, any>;
    required: string[];
  };
}

export const whiteboardFunctions: WhiteboardFunction[] = [
  {
    name: 'draw_line',
    description: 'Ø±Ø³Ù… Ø®Ø· Ù…Ø³ØªÙ‚ÙŠÙ… Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø¨ÙˆØ±Ø©',
    parameters: {
      type: 'object',
      properties: {
        from_x: { type: 'number', description: 'Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ - Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„Ø³ÙŠÙ†ÙŠ' },
        from_y: { type: 'number', description: 'Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ - Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„ØµØ§Ø¯ÙŠ' },
        to_x: { type: 'number', description: 'Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ© - Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„Ø³ÙŠÙ†ÙŠ' },
        to_y: { type: 'number', description: 'Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ© - Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„ØµØ§Ø¯ÙŠ' },
        color: { type: 'string', description: 'Ù„ÙˆÙ† Ø§Ù„Ø®Ø·', default: '#000000' },
        thickness: { type: 'number', description: 'Ø³Ù…Ùƒ Ø§Ù„Ø®Ø·', default: 2 }
      },
      required: ['from_x', 'from_y', 'to_x', 'to_y']
    }
  },
  
  {
    name: 'draw_circle',
    description: 'Ø±Ø³Ù… Ø¯Ø§Ø¦Ø±Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø¨ÙˆØ±Ø©',
    parameters: {
      type: 'object',
      properties: {
        center_x: { type: 'number', description: 'Ù…Ø±ÙƒØ² Ø§Ù„Ø¯Ø§Ø¦Ø±Ø© - Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„Ø³ÙŠÙ†ÙŠ' },
        center_y: { type: 'number', description: 'Ù…Ø±ÙƒØ² Ø§Ù„Ø¯Ø§Ø¦Ø±Ø© - Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„ØµØ§Ø¯ÙŠ' },
        radius: { type: 'number', description: 'Ù†ØµÙ Ù‚Ø·Ø± Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©' },
        color: { type: 'string', description: 'Ù„ÙˆÙ† Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©', default: '#000000' },
        fill: { type: 'boolean', description: 'Ù…Ù„Ø¡ Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©', default: false }
      },
      required: ['center_x', 'center_y', 'radius']
    }
  },
  
  {
    name: 'write_text',
    description: 'ÙƒØªØ§Ø¨Ø© Ù†Øµ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø¨ÙˆØ±Ø©',
    parameters: {
      type: 'object',
      properties: {
        x: { type: 'number', description: 'Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù†Øµ - Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„Ø³ÙŠÙ†ÙŠ' },
        y: { type: 'number', description: 'Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù†Øµ - Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„ØµØ§Ø¯ÙŠ' },
        text: { type: 'string', description: 'Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ø±Ø§Ø¯ ÙƒØªØ§Ø¨ØªÙ‡' },
        size: { type: 'number', description: 'Ø­Ø¬Ù… Ø§Ù„Ø®Ø·', default: 16 },
        color: { type: 'string', description: 'Ù„ÙˆÙ† Ø§Ù„Ù†Øµ', default: '#000000' }
      },
      required: ['x', 'y', 'text']
    }
  },
  
  {
    name: 'draw_triangle',
    description: 'Ø±Ø³Ù… Ù…Ø«Ù„Ø« Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø¨ÙˆØ±Ø©',
    parameters: {
      type: 'object',
      properties: {
        x1: { type: 'number', description: 'Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ - Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„Ø³ÙŠÙ†ÙŠ' },
        y1: { type: 'number', description: 'Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ - Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„ØµØ§Ø¯ÙŠ' },
        x2: { type: 'number', description: 'Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ© - Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„Ø³ÙŠÙ†ÙŠ' },
        y2: { type: 'number', description: 'Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ© - Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„ØµØ§Ø¯ÙŠ' },
        x3: { type: 'number', description: 'Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø© - Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„Ø³ÙŠÙ†ÙŠ' },
        y3: { type: 'number', description: 'Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø© - Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„ØµØ§Ø¯ÙŠ' },
        color: { type: 'string', description: 'Ù„ÙˆÙ† Ø§Ù„Ù…Ø«Ù„Ø«', default: '#000000' }
      },
      required: ['x1', 'y1', 'x2', 'y2', 'x3', 'y3']
    }
  },
  
  {
    name: 'draw_arrow',
    description: 'Ø±Ø³Ù… Ø³Ù‡Ù… Ù„Ù„Ø¥Ø´Ø§Ø±Ø© Ø¥Ù„Ù‰ Ø´ÙŠØ¡ Ù…Ø¹ÙŠÙ†',
    parameters: {
      type: 'object',
      properties: {
        from_x: { type: 'number', description: 'Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø³Ù‡Ù… - Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„Ø³ÙŠÙ†ÙŠ' },
        from_y: { type: 'number', description: 'Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø³Ù‡Ù… - Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„ØµØ§Ø¯ÙŠ' },
        to_x: { type: 'number', description: 'Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø³Ù‡Ù… - Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„Ø³ÙŠÙ†ÙŠ' },
        to_y: { type: 'number', description: 'Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø³Ù‡Ù… - Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„ØµØ§Ø¯ÙŠ' },
        color: { type: 'string', description: 'Ù„ÙˆÙ† Ø§Ù„Ø³Ù‡Ù…', default: '#ff0000' }
      },
      required: ['from_x', 'from_y', 'to_x', 'to_y']
    }
  },
  
  {
    name: 'clear_whiteboard',
    description: 'Ù…Ø³Ø­ Ø§Ù„Ø³Ø¨ÙˆØ±Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„',
    parameters: {
      type: 'object',
      properties: {},
      required: []
    }
  },
  
  {
    name: 'highlight_area',
    description: 'ØªØ¸Ù„ÙŠÙ„ Ù…Ù†Ø·Ù‚Ø© Ù…Ø¹ÙŠÙ†Ø© Ù„Ù„ÙØª Ø§Ù„Ø§Ù†ØªØ¨Ø§Ù‡',
    parameters: {
      type: 'object',
      properties: {
        x: { type: 'number', description: 'Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø¹Ù„ÙˆÙŠØ© Ø§Ù„ÙŠØ³Ø±Ù‰ - Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„Ø³ÙŠÙ†ÙŠ' },
        y: { type: 'number', description: 'Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø¹Ù„ÙˆÙŠØ© Ø§Ù„ÙŠØ³Ø±Ù‰ - Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„ØµØ§Ø¯ÙŠ' },
        width: { type: 'number', description: 'Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù†Ø·Ù‚Ø©' },
        height: { type: 'number', description: 'Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ù…Ù†Ø·Ù‚Ø©' },
        color: { type: 'string', description: 'Ù„ÙˆÙ† Ø§Ù„ØªØ¸Ù„ÙŠÙ„', default: '#ffff00' },
        opacity: { type: 'number', description: 'Ø´ÙØ§ÙÙŠØ© Ø§Ù„ØªØ¸Ù„ÙŠÙ„', default: 0.3 }
      },
      required: ['x', 'y', 'width', 'height']
    }
  }
];

export class WhiteboardFunctionExecutor {
  constructor(private whiteboard: WhiteboardEngine) {}
  
  async executeFunction(functionName: string, parameters: any): Promise<string> {
    switch (functionName) {
      case 'draw_line':
        return this.whiteboard.drawLine(
          { x: parameters.from_x, y: parameters.from_y },
          { x: parameters.to_x, y: parameters.to_y },
          {
            strokeColor: parameters.color || '#000000',
            strokeWidth: parameters.thickness || 2,
            opacity: 1
          }
        );
        
      case 'draw_circle':
        return this.whiteboard.drawCircle(
          { x: parameters.center_x, y: parameters.center_y },
          parameters.radius,
          {
            strokeColor: parameters.color || '#000000',
            fillColor: parameters.fill ? parameters.color : undefined,
            strokeWidth: 2,
            opacity: 1
          }
        );
        
      case 'write_text':
        return this.whiteboard.writeText(
          { x: parameters.x, y: parameters.y },
          parameters.text,
          {
            strokeColor: parameters.color || '#000000',
            fontSize: parameters.size || 16,
            fontFamily: 'Arial',
            strokeWidth: 1,
            opacity: 1,
            text: parameters.text
          }
        );
        
      case 'draw_triangle':
        return this.whiteboard.drawTriangle(
          { x: parameters.x1, y: parameters.y1 },
          { x: parameters.x2, y: parameters.y2 },
          { x: parameters.x3, y: parameters.y3 },
          {
            strokeColor: parameters.color || '#000000',
            strokeWidth: 2,
            opacity: 1
          }
        );
        
      case 'draw_arrow':
        return this.whiteboard.drawArrow(
          { x: parameters.from_x, y: parameters.from_y },
          { x: parameters.to_x, y: parameters.to_y },
          {
            strokeColor: parameters.color || '#ff0000',
            strokeWidth: 2,
            opacity: 1
          }
        );
        
      case 'clear_whiteboard':
        this.whiteboard.clear();
        return 'whiteboard_cleared';
        
      case 'highlight_area':
        // ØªÙ†ÙÙŠØ° ØªØ¸Ù„ÙŠÙ„ Ø§Ù„Ù…Ù†Ø·Ù‚Ø©
        return 'area_highlighted';
        
      default:
        throw new Error(`Unknown function: ${functionName}`);
    }
  }
}
```

---

## ğŸ¨ **Ù…ÙƒÙˆÙ† React Ù„Ù„Ø³Ø¨ÙˆØ±Ø©**

```typescript
// components/VirtualWhiteboard.tsx
'use client';

import { useRef, useEffect, useState } from 'react';
import { WhiteboardEngine, WhiteboardFunctionExecutor } from '@/lib/whiteboard-engine';
import { Eraser, Download, RotateCcw } from 'lucide-react';

interface VirtualWhiteboardProps {
  onFunctionCall?: (functionName: string, parameters: any) => Promise<void>;
  className?: string;
}

export default function VirtualWhiteboard({ 
  onFunctionCall, 
  className = '' 
}: VirtualWhiteboardProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [whiteboard, setWhiteboard] = useState<WhiteboardEngine | null>(null);
  const [executor, setExecutor] = useState<WhiteboardFunctionExecutor | null>(null);
  
  useEffect(() => {
    if (canvasRef.current) {
      const wb = new WhiteboardEngine(canvasRef.current);
      const exec = new WhiteboardFunctionExecutor(wb);
      
      setWhiteboard(wb);
      setExecutor(exec);
      
      // Ø±Ø¨Ø· executor Ù…Ø¹ onFunctionCall
      if (onFunctionCall) {
        // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ù„Ù…Ø¹Ù„Ù… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ
        window.whiteboardExecutor = exec;
      }
    }
  }, [onFunctionCall]);
  
  const clearWhiteboard = () => {
    whiteboard?.clear();
  };
  
  const downloadWhiteboard = () => {
    if (canvasRef.current) {
      const link = document.createElement('a');
      link.download = 'whiteboard.png';
      link.href = canvasRef.current.toDataURL();
      link.click();
    }
  };
  
  return (
    <div className={`whiteboard-container ${className}`}>
      {/* Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØªØ­ÙƒÙ… */}
      <div className="whiteboard-controls">
        <button
          onClick={clearWhiteboard}
          className="control-button"
          title="Ù…Ø³Ø­ Ø§Ù„Ø³Ø¨ÙˆØ±Ø©"
        >
          <Eraser className="w-5 h-5" />
        </button>
        
        <button
          onClick={downloadWhiteboard}
          className="control-button"
          title="ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø³Ø¨ÙˆØ±Ø©"
        >
          <Download className="w-5 h-5" />
        </button>
      </div>
      
      {/* Ø§Ù„Ø³Ø¨ÙˆØ±Ø© */}
      <canvas
        ref={canvasRef}
        className="whiteboard-canvas"
        width={800}
        height={600}
      />
      
      <style jsx>{`
        .whiteboard-container {
          position: relative;
          border: 2px solid #e5e7eb;
          border-radius: 8px;
          background: white;
          overflow: hidden;
        }
        
        .whiteboard-controls {
          position: absolute;
          top: 10px;
          right: 10px;
          display: flex;
          gap: 8px;
          z-index: 10;
        }
        
        .control-button {
          padding: 8px;
          background: rgba(255, 255, 255, 0.9);
          border: 1px solid #d1d5db;
          border-radius: 6px;
          cursor: pointer;
          transition: all 0.2s;
        }
        
        .control-button:hover {
          background: rgba(255, 255, 255, 1);
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .whiteboard-canvas {
          display: block;
          width: 100%;
          height: 100%;
          cursor: crosshair;
        }
      `}</style>
    </div>
  );
}
```

---

## ğŸ¯ **Ø£Ù…Ø«Ù„Ø© ØªØ·Ø¨ÙŠÙ‚ÙŠØ© Ù„Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©**

### **Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª:**
- Ø±Ø³Ù… Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ© ÙˆØ§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª
- ØªÙˆØ¶ÙŠØ­ Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠØ© ÙˆØ§Ù„Ø¯ÙˆØ§Ù„
- Ø­Ù„ Ø§Ù„Ù…Ø³Ø§Ø¦Ù„ Ø®Ø·ÙˆØ© Ø¨Ø®Ø·ÙˆØ© Ø¨ØµØ±ÙŠØ§Ù‹

### **Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¡:**
- Ø±Ø³Ù… Ø§Ù„Ø¯ÙˆØ§Ø¦Ø± Ø§Ù„ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠØ©
- ØªÙˆØ¶ÙŠØ­ Ø§Ù„Ù‚ÙˆÙ‰ ÙˆØ§Ù„Ø­Ø±ÙƒØ©
- Ø±Ø³Ù… Ø§Ù„Ù…ÙˆØ¬Ø§Øª ÙˆØ§Ù„Ø°Ø¨Ø°Ø¨Ø§Øª

### **Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¡:**
- Ø±Ø³Ù… Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¦ÙŠØ©
- ØªÙˆØ¶ÙŠØ­ Ø¨Ù†ÙŠØ© Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª
- Ø±Ø³Ù… Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø¯ÙˆØ±ÙŠ Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠ

### **Ø§Ù„Ø¨Ø±Ù…Ø¬Ø©:**
- Ø±Ø³Ù… Ø®Ø±Ø§Ø¦Ø· Ø§Ù„ØªØ¯ÙÙ‚ (Flowcharts)
- ØªÙˆØ¶ÙŠØ­ Ù‡ÙŠØ§ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
- Ø±Ø³Ù… Ù…Ø®Ø·Ø·Ø§Øª UML

---

**ğŸ¯ Ø§Ù„Ù‡Ø¯Ù: ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¯Ø±Ø³ Ø¥Ù„Ù‰ ØªØ¬Ø±Ø¨Ø© Ø¨ØµØ±ÙŠØ© ØªÙØ§Ø¹Ù„ÙŠØ© ØªØ¹Ø²Ø² Ø§Ù„ÙÙ‡Ù… ÙˆØ§Ù„Ø§Ø³ØªÙŠØ¹Ø§Ø¨**
